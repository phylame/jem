/*
 * Copyright 2017 Peng Wan <phylame@163.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jem.imabw.app

import jem.Book
import jem.Chapter
import jem.epm.EpmManager
import jem.imabw.app.ui.Dialogs
import jem.imabw.app.ui.Viewer
import jem.kotlin.get
import jem.kotlin.title
import pw.phylame.commons.io.PathUtils
import pw.phylame.qaf.core.App
import pw.phylame.qaf.core.tr
import pw.phylame.qaf.ixin.Command
import java.io.File
import java.nio.charset.Charset
import java.util.*
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

object History {
    const val ENCODING = "UTF-8"
    const val FILE_NAME = "history"

    private val histories = LinkedList<String>()
    private var isModified = false

    // update UI components, eg: menu
    var updater: (() -> Unit)? = null

    private val file: File by lazy {
        File(App.home, "$SETTINGS_DIR$FILE_NAME")
    }

    init {
        load()
        App.cleanups.add(Runnable { sync() })
    }

    val items: Sequence<String> get() = histories.asSequence()

    fun append(file: File, updating: Boolean = false) {
        if (!AppSettings.isHistoryEnable) {
            return
        }
        val path = file.canonicalPath
        if (path !in histories) {
            if (histories.size > AppSettings.historyLimits) {
                histories.removeLast()
            }
            histories.addFirst(path)
            isModified = true
            if (updating) {
                updateUI()
            }
        }
    }

    fun remove(file: File, updating: Boolean = false) {
        if (!AppSettings.isHistoryEnable) {
            return
        }
        val path = file.canonicalPath
        if (histories.remove(path)) {
            isModified = true
            if (updating) {
                updateUI()
            }
        }
    }

    fun clear(updating: Boolean = false) {
        if (!AppSettings.isHistoryEnable) {
            return
        }
        if (histories.isNotEmpty()) {
            histories.clear()
            isModified = true
            if (updating) {
                updateUI()
            }
        }
    }

    fun updateUI() {
        updater?.invoke()
    }

    private fun load() {
        if (!AppSettings.isHistoryEnable) {
            return
        }
        val file = file
        if (!file.exists()) {
            return
        }
        file.bufferedReader(Charset.forName(ENCODING)).useLines {
            histories.addAll(
                    it.filter { it.isNotEmpty() && !it.startsWith('#') }
                            .take(AppSettings.historyLimits)
                            .distinct())
        }
    }

    private fun sync() {
        if (!AppSettings.isHistoryEnable) {
            return
        }
        if (!isModified) {
            return
        }
        file.writeText(histories.joinToString(System.lineSeparator(), "# DO NOT EDIT THIS FILE"), Charset.forName(ENCODING))
    }
}

class Task(val book: Book,
           val inParam: EpmInParam? = null,
           val outParam: EpmOutParam? = null,
           val updater: (Task) -> Unit) {

    companion object {
        val taskPool: ExecutorService = Executors.newFixedThreadPool(8)
    }

    constructor(book: Book, updater: (Task) -> Unit) : this(book, null, null, updater)

    // test current book of the activeTask modification state
    val isModified: Boolean get() = isModifiedOf(book)

    // test the specified book modification state
    fun isModifiedOf(chapter: Chapter): Boolean = if (chapter === book) {
        states.any { it.value.isModified }
    } else {
        states[chapter]?.isModified ?: false
    }

    // set modification state of text for specified book
    fun fireTextModified(chapter: Chapter, modified: Boolean) {
        stateOf(chapter).textModified(modified)
        updater(this)
    }

    // set modification state of contents for specified book
    fun fireContentsModified(chapter: Chapter, modified: Boolean) {
        stateOf(chapter).contentsModified(modified)
        updater(this)
    }

    // set modification state of attributes for specified book
    fun fireAttributeModified(chapter: Chapter, modified: Boolean) {
        stateOf(chapter).attributeModified(modified)
        updater(this)
    }

    // set modification state of extensions for the book
    fun fireExtensionModified(modified: Boolean) {
        stateOf(book).extensionModified(modified)
        updater(this)
    }

    fun cleanup() {
        taskPool.submit {
            book.cleanup()
        }
        val source = inParam?.file
        if (source != null) {
            History.append(source, false)
        }
    }

    // keeps state of chapters
    private val states = IdentityHashMap<Chapter, State>()

    // get or create state for specified book
    private fun stateOf(chapter: Chapter): State = states.getOrPut(chapter) { State(chapter) }

    // hold modification state of book
    private inner class State(val chapter: Chapter) {
        // count of text modification
        var text = 0

        // count of contents modification
        var contents = 0

        // count of attributes modification
        var attribute = 0

        // count of extension(only for book) modification
        var extension = 0

        // test the book(or book) is modified or not
        val isModified: Boolean get() = text > 0 || contents > 0 || attribute > 0 || extension > 0

        // reset all to unmodified state
        fun reset() {
            text = 0
            contents = 0
            attribute = 0
            extension = 0
        }

        fun textModified(modified: Boolean) {
            text += if (modified) 1 else -1
            if (text < 0) {
                text = 0
            }
            App.echo("${chapter.title} text state: $text")
        }

        fun attributeModified(modified: Boolean) {
            attribute += if (modified) 1 else -1
            if (attribute < 0) {
                attribute = 0
            }
            App.echo("${chapter.title} attribute state: $attribute")
        }

        fun contentsModified(modified: Boolean) {
            contents += if (modified) 1 else -1
            if (contents < 0) {
                contents = 0
            }
            App.echo("${chapter.title} contents state: $contents")
        }

        fun extensionModified(modified: Boolean) {
            extension += if (modified) 1 else -1
            if (extension < 0) {
                extension = 0
            }
            App.echo("${chapter.title} extension state: $extension")
        }
    }
}

object Manager {
    init {
        History.updater = {
            Viewer.updateHistory()
        }
    }

    var task: Task? = null
        set (value) {
            if (value == null) {
                throw NullPointerException("task cannot be null")
            }
            if (value === field) { // already activated
                App.echo("task is already activated")
                return
            }

            // cleanup current task
            field?.cleanup()

            // activate new task
            field = value

            val file = value.inParam?.file
            if (file != null) {
                History.remove(file, true)
                Dialogs.setDirectory(file)
                Viewer.actions[FILE_DETAILS]?.isEnabled = true
            } else {
                Viewer.actions[FILE_DETAILS]?.isEnabled = false
            }
            Viewer.updateBook(value.book)
        }

    fun maybeSaving(title: String): Boolean = if (!(task?.isModified ?: false)) {// not modified
        true
    } else when (Dialogs.saving(Viewer, title, tr("d.askSaving.tip"))) { // ask for saving
        Dialogs.OPTION_DISCARD -> true
        Dialogs.OPTION_OK -> saveFile()
        else -> false
    }

    fun openBook(title: String, param: EpmInParam) {
        if (!param.file.exists()) {
            Dialogs.error(Viewer, title, tr("d.openBook.fileNotExist", param.file))
            return
        }
        if (!EpmManager.hasParser(param.format)) {
            Dialogs.error(Viewer, title, tr("d.openBook.unsupportedFormat", param.format))
            return
        }
        Books.openBook(title, true, arrayOf(param), object : OpeningObserver() {
            override fun onBook(book: Book, param: EpmInParam) {
                task?.cleanup()
                task = Task(book, param) {

                }
            }
        })
    }

    private fun updateBookState(task: Task) {

    }

    @Command(OPEN_FILE)
    fun openFile() {
        openFile(null)
    }

    fun openFile(file: File?) {
        val title = tr("d.openBook.title")
        if (!maybeSaving(title)) {
            return
        }
        val param = Books.selectBook(Viewer,
                title,
                file,
                if (file == null) task?.inParam?.format else PathUtils.extName(file.path)) ?: return
        openBook(title, param)
    }

    @Command(NEW_FILE)
    fun newFile() {
        newFile(null)
    }

    fun newFile(name: String?) {
        val title = tr("d.newBook.title")
        if (!maybeSaving(title)) {
            return
        }

        // create new book in dialog
        val book = Book("Example", "PW")
        for (i in 1..10) {
            val section = Chapter("Section $i")
            book.append(section)
            for (j in 1..5) {
                section.append(Chapter("Chapter $i.$j"))
            }
        }

        task?.cleanup()

        task = Task(book) {

        }
        task?.fireContentsModified(book[2], true)
        task?.fireContentsModified(book[3][1], true)
        History.updateUI()
//
//        val book = Books.newBook(Viewer, title, name) ?: return
//        if (task != null) {
//            pool.submit {
//                task!!.cleanup()
//            }
//        }
//        task = Task(book) {
//            updateBookState(it)
//        }
        Imabw.message("d.newBook.done", book.title)
    }

    @Command(SAVE_FILE)
    fun saveFile(): Boolean {
        // todo: save all tabs, show waiting, do saving, close waiting
        return true
    }

    @Command(SAVE_AS_FILE)
    fun saveAsFile() {
        Dialogs.confirm(Viewer, "Open File", true, "Let's go\n继续下一步，确定，再确定，确定删除文件么？")
    }

    @Command(FILE_DETAILS)
    fun viewDetails() {
        val task = task
        if (task != null) {
            Dialogs.bookDetails(Viewer, task.book, task.inParam!!.file)
        } else {
            App.error("not found active task")
        }
    }

    @Command(CLEAR_HISTORY)
    fun clearHistory() {
        History.clear(true)
    }

    @Command(EXIT_APP)
    fun exitApp() {
        if (!maybeSaving(tr("d.exitApp.title"))) {
            return
        }
        task?.cleanup()
        App.exit(0)
    }
}
